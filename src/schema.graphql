# import DateTime from "./lib/generated/schema/prisma.graphql"

#
# Directives
#
# Implements authorization rules.
directive @auth(
  permission: String,
) on OBJECT | FIELD_DEFINITION

# Wraps fields to alias a synthetic field to an underlying actual field
directive @alias(
  field: String!
) on FIELD_DEFINITION

#
# Scalars
#
scalar JSON
scalar Uuid

#
# Enums
#
enum EntityType {
  WORKSPACE
  DEPLOYMENT
  SYSTEM
}

#
# Types
#
type AuthUser {
  user: User
  token: Token
  permissions: JSON
  isAdmin: Boolean
}

type Token {
  value: String
  payload: TokenPayload
}

type TokenPayload {
  uuid: Uuid
  iat: Int
  exp: Int
}

type AuthConfig {
  publicSignup: Boolean
  initialSignup: Boolean
  localEnabled: Boolean
  googleEnabled: Boolean
  githubEnabled: Boolean
  auth0Enabled: Boolean
  oktaEnabled: Boolean
  googleOAuthUrl: String
  githubOAuthUrl: String
  auth0OAuthUrl: String
  oktaOAuthUrl: String
}

type Invite {
  id: ID!
  uuid: Uuid @alias(field: "id")
  assignments: String @deprecated
  role: Role!
  email: String
  token: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Group {
  id: ID!
  uuid: Uuid @alias(field: "id")
  label: String
  active: Boolean
  custom: Boolean
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

# This only exists to support the legacy API.
type UserProp {
  key: String
  value: String
  category: String
}

type User {
  id: ID!
  uuid: Uuid @alias(field: "id")
  username: String
  emails: [Email!]!
  fullName: String
  status: String
  profile: [UserProp!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  roleBindings: [RoleBinding!]
}

type Workspace {
  id: ID!
  uuid: Uuid @alias(field: "id")
  active: Boolean
  description: String
  invites: [Invite!]!
  properties: JSON
  label: String
  users: [User]
  groups: [Group]
  deploymentCount: Int
  stripeCustomerId: String
  roleBindings: [RoleBinding!]
  workspaceCapabilities: WorkspaceCapabilities
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DeploymentConfig {
  defaults: JSON
  limits: JSON
  astroUnit: AstroUnit
  maxExtraAu: Int
  executors: JSON
  latestVersion: String
  singleNamespace: Boolean!
  loggingEnabled: Boolean!
}

type WorkspaceCapabilities {
  canUpdateBilling: Boolean
  canUpdateIAM: Boolean
}

type AstroUnit {
  cpu: Int
  memory: Int
  pods: Float
  airflowConns: Float
  actualConns: Float
  price: Float
}

type DeploymentUrl {
  type: String
  url: String
}

type DeployInfo {
  latest: String
  next: String
}

# Deployment properties are only to support the legacy API.
# Properties have been moved to top-level fields on Deployment internally.
type Deployment {
  id: ID!
  uuid: Uuid @alias(field: "id")
  config: JSON
  env: JSON
  properties: JSON
  urls: [DeploymentUrl]
  description: String
  label: String
  releaseName: String
  status: String
  type: String
  version: String
  airflowVersion: String
  deployInfo: DeployInfo
  workspace: Workspace
  createdAt: DateTime!
  updatedAt: DateTime!
  roleBindings: [RoleBinding!]
}

type ServiceAccount {
  id: ID!
  uuid: Uuid @alias(field: "id")
  apiKey: String
  label: String
  category: String
  entityType: String
  entityUuid: Uuid
  active: Boolean
  lastUsedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  roleBinding: RoleBinding!
}

type DeploymentLog {
  id: ID!
  uuid: Uuid @alias(field: "id")
  timestamp: String
  release: String
  component: String
  level: String
  message: String
}

type Card {
  name: String
  expMonth: Int!
  expYear: Int!
  last4: String!
  brand: String
  billingEmail: String
  company: String
}

type Metric {
  label: String
  result: JSON
}

#
# Queries
#
type Query {
  users(
    userUuid: Uuid
    username: String
    email: String
  ): [User] @auth

  authConfig(
    redirect: String
    duration: Int
    extras: JSON
    inviteToken: String
  ): AuthConfig

  self: AuthUser @auth

  workspaces(
    userUuid: Uuid
    workspaceUuid: Uuid
    label: String
  ): [Workspace] @auth

  deploymentConfig(
    workspaceUuid: Uuid
    deploymentUuid: Uuid
    type: String
    version: String
  ): DeploymentConfig @auth

  deployments(
    workspaceUuid:  Uuid
    deploymentUuid: Uuid # Ignored, only here for backward compatibility.
    releaseName: String
  ): [Deployment] @auth # Permissions checked in resolver, due to limitations with current API design.

  serviceAccounts(
    serviceAccountUuid: Uuid
    entityType: EntityType!
    entityUuid: Uuid
  ): [ServiceAccount] @auth

  invites(
    workspaceUuid: Uuid
    email: String
  ): [Invite] @auth(permission: "workspace.invites.get")

  logs(
    deploymentUuid: Uuid!
    component: String
    timestamp: DateTime
    search: String
  ): [DeploymentLog] @auth(permission: "deployment.logs.get")

  card(
    workspaceUuid: Uuid!
    stripeCustomerId: String!
  ): Card @auth(permission: "workspace.billing.update")
}

#
# Mutations
#
type Mutation {
  createUser(
    email: String!
    password: String!
    username: String
    profile: JSON
    inviteToken: String
    duration: Int
  ): AuthUser

  confirmEmail(
    token: String!
    duration: Int
  ): AuthUser

  createToken(
    password: String!
    identity: String
    duration: Int
  ): AuthUser

  forgotPassword(
    email: String!
  ) : Boolean!

  resendConfirmation(
    email: String!
  ): Boolean!

  resetPassword(
    token: String!
    password: String!
    duration: Int
  ): AuthUser

  createDeployment(
    workspaceUuid: Uuid!
    type: String!
    label: String!
    description: String
    version: String
    airflowVersion: String
    config: JSON
    env: JSON
    properties: JSON
  ): Deployment @auth(permission: "workspace.deployments.create")

  updateDeployment(
    deploymentUuid: Uuid!
    payload: JSON
    config: JSON
    env: JSON
    sync: Boolean
  ): Deployment @auth(permission: "deployment.config.update")

  deleteDeployment(
    deploymentUuid: Uuid!
  ): Deployment @auth(permission: "deployment.config.delete")

  deleteWorkspace(
    workspaceUuid: Uuid
  ): Workspace @auth(permission: "workspace.config.delete")

  updateUser(
    userId: Uuid,
    payload: JSON!
  ): User @auth

  createWorkspace(
    label: String!
    description: String
  ): Workspace @auth

  workspaceAddUser(
    workspaceUuid: Uuid
    email: String!
    # For backwards compatibility specify the previous behaviour as default value
    role: Role! = WORKSPACE_VIEWER
  ): Workspace @auth(permission: "workspace.iam.update")

  workspaceUpdateUserRole(
    workspaceUuid: Uuid!
    email: String!
    role: Role!
  ): Role @auth(permission: "workspace.iam.update")

  workspaceRemoveUser(
    workspaceUuid: Uuid!
    userUuid: Uuid!
  ): Workspace @auth(permission: "workspace.iam.update")

  deleteInviteToken(
    inviteUuid: Uuid
  ): Invite @auth

  updateWorkspace(
    workspaceUuid: Uuid!
    payload: JSON!
  ): Workspace @auth(permission: "workspace.config.update")

  upgradeDeployment(
    deploymentUuid: Uuid!
    version: String!
  ): Deployment @auth(permission: "deployment.config.update")

  # ServiceAccount mutations are handled differently at the moment to maintain
  # backward compatibility with CLI / UI. We should refactor to
  # more explicit, scoped mutations.
  createServiceAccount(
    label: String!
    category: String
    entityType: EntityType!
    entityUuid: Uuid
  ): ServiceAccount @auth

  updateServiceAccount(
    serviceAccountUuid: Uuid!
    payload: JSON!
  ): ServiceAccount @auth

  deleteServiceAccount(
    serviceAccountUuid: Uuid!
  ): ServiceAccount @auth

  createSystemRoleBinding(
    userId: ID!
    role: Role!
  ): RoleBinding @auth(permission: "system.iam.update")

  addCard(
    workspaceUuid: Uuid!
    billingEmail: String!
    company: String
    token: String!
  ): Card @auth(permission: "workspace.billing.update")

  updateCard(
    workspaceUuid: Uuid!
    billingEmail: String!
    company: String
    token: String!
  ): Card @auth(permission: "workspace.billing.update")
}

#
# Subscriptions
#
type Subscription {
  log(
    deploymentUuid: Uuid!
    component: String
    timestamp: DateTime
    search: String
  ): DeploymentLog @auth(permission: "deployment.logs.get")

  metrics(
    deploymentUuid: Uuid!
    since: Int,
    step: Int,
  ): [Metric] @auth(permission: "deployment.metrics.get")
}
